#!/usr/bin/perl

## Easy GIT (eg), a usable version of git.
## Copyright 2008 by Elijah Newren
## Licensed under GNU GPL, version 2.

package main;

use warnings;
use Getopt::Long;
use List::Util qw(min max);

# configurables
my $verbose=0;

# globals :-(
my $outfh;
my $version = "0.5.4.alphabeticalcharactersdontbelonginversionnumbers";
my %command;    # command=>{section, short_description} mapping
my $section = {
  'creation' =>
    { order => 1,
      desc  => 'Creating and updating projects and project containers',
    },
  'discovery' =>
    { order => 2,
      desc  => 'Obtaining information about changes, history, & state',
    },
  'modification' =>
    { order => 3,
      desc  => 'Making, undoing, or recording changes',
    },
  'projects' =>
    { order => 4,
      desc  => 'Managing multiple projects (branches) & collaboration'
    },
  'misc' =>
    { order => 5,
      desc  => 'Miscellaneous'
    },
  };



#*************************************************************************#
#*************************************************************************#
#*************************************************************************#
#                   CLASSES DEFINING ACTIONS TO PERFORM                   #
#*************************************************************************#
#*************************************************************************#
#*************************************************************************#

###########################################################################
# subcommand, a base class for all eg subcommands                         #
###########################################################################
package subcommand;
sub new {
  my $class = shift;
  my $self = {@_};  # Hashref initialized as we're told
  bless($self, $class);

  # We allow direct instantiation of the subcommand class only if they
  # provide a command name for us to pass to git.
  if (ref($class) eq "subcommand" && !defined $self->{command}) {
    die "Invalid subcommand usage"
  }

  return $self;
}

sub help {
  my $self = shift;
  my $package_name = ref($self);

  if ($package_name eq "subcommand") {
    exit ExecUtil::execute("git $self->{command} --help")
  }

  open(OUTPUT, "|less");
  print OUTPUT "$package_name: $command{$package_name}{about}\n";
  print OUTPUT $self->{'help'};
  print OUTPUT "\nDifferences from git $package_name:";
  print OUTPUT "\n  None.\n" if !defined $self->{'differences'};
  print OUTPUT $self->{'differences'} if defined $self->{'differences'};
  print OUTPUT "\nSee also\n";
  print OUTPUT <<EOF;
  Run 'man git-$package_name' for a comprehensive list of options available.
  eg $package_name is designed to accept the same options with the same
  meanings (unless specified otherwise in the above "Differences" section).
EOF
  close(OUTPUT);
  exit 0;
}

sub preprocess {
  my $self = shift;

  my $result=main::GetOptions("--help" => sub { $self->help() });
}

sub run {
  my $self = shift;
  my $package_name = ref($self);

  my $subcommand = 
    $package_name eq "subcommand" ? $self->{'command'} : $package_name;

  return ExecUtil::execute("git $subcommand @ARGV", ignore_ret => 1);
}

###########################################################################
# add                                                                     #
###########################################################################
package add;
@add::ISA = qw(subcommand);
INIT {
  $command{add} = {
    section => 'modification',
    about => 'Mark content in files as being ready for commit'
    };
}

sub new {
  my $class = shift;
  my $self = $class->SUPER::new();
  bless($self, $class);
  $self->{'help'} = "
Usage:
  eg add [--] <PATH> ...

Description:
  Marks the contents of the specified files as being ready to commit,
  scheduling them for addition to the repository.  (This is also known as
  staging.)  When a directory is passed, all files in that directory or any
  subdirectory are recursively added.

Examples:
  Create a new file, and mark it for addition to the repository.
      \$ echo hi > there
      \$ eg add there

  (Advanced) Mark some changes as good, add some verbose sanity checking code,
  then commit just the good changes.
      Implement some cool new feature in somefile.C
      \$ eg add somefile.C
      Add some verbose sanity checking code to somefile.C
      Decide to commit the new feature code but not the sanity checking code:
      \$ eg commit --staged

  (Advanced) Show changes in a file, split by those that you have marked as
  good and those that you haven't:
      Make various edits
      \$ eg add file1 file2
      Make more edits, include some to file1
      \$ eg diff            # Look at all the changes
      \$ eg diff --staged   # Look at the \"ready to be committed\" changes
      \$ eg diff --unstaged # Look at the changes not ready to be commited

Options:
  --
    This option can be used to separate command-line options from the list
    of files, (useful when filenames might be mistaken for command-line
    options).
";
  return $self;
}

###########################################################################
# branch                                                                  #
###########################################################################
package branch;
@branch::ISA = qw(subcommand);
INIT {
  $command{branch} = {
    section => 'projects',
    about => 'List existing projects (branches)'
    };
}

sub new {
  my $class = shift;
  my $self = $class->SUPER::new();
  bless($self, $class);
  $self->{'help'} = "
Usage:
  eg branch

Description:
  List the existing branches that you can switch to, with the
  currently active branch marked with an asterisk.
";
  return $self;
}

###########################################################################
# commit                                                                  #
###########################################################################
package commit;
@commit::ISA = qw(subcommand);
INIT {
  $command{commit} = {
    section => 'modification',
    about => 'Record changes locally'
    };
  $alias{'checkin'} = "commit";
  $alias{'ci'}      = "commit";
}

sub new {
  my $class = shift;
  my $self = $class->SUPER::new();
  bless($self, $class);
  $self->{'help'} = "
Usage:
  eg commit [-a|--all-tracked] [-b|--bypass-untracked-check]
            [--staged|-d|--dirty] [-F <file> | -m <msg> | --amend]
            [--] [<file>...]

Description:
  Records changes locally along with a log message describing the
  changes you have made.  If no -F or -m option is supplied, an editor
  is opened for you to enter a log message.

  In order to prevent common errors, the commit will abort with a warning
  message if there are no changes to commit or if it detects that the
  choice of what to commit is ambiguous.  In particular, if you have any
  untracked files present, or if you have both staged changes (i.e. changes
  explicitly marked as ready for commit) and unstaged changes, then you
  will get a warning rather than having the commit occur.  You can run 'eg
  status' to get the status of various files and their changes.  These
  commit checks can be bypassed with various options.

Examples:
  Record current changes locally, not changing anything in CVS...OR...get
  a warning message if eg detects that the choice of what to commit is not
  necessarily clear.
      \$ eg commit

  Record current changes, ignoring any untracked files present.
      \$ eg commit -b

  Record brand new file and current changes.
      \$ eg add file.c
      \$ eg commit -a
  Note: Running 'eg add <file>' explicitly marks <file> as being ready to
  commit.  Since you likely haven't explicitly marked your other changes as
  ready to commit, pass the -a flag to specify that both kinds of changes
  should be recorded.

  (Advanced) Record staged changes, ignoring both unstaged changes and
  untracked files.
      \$ eg commit --staged

Options:
  -a|--all-tracked
    (Could also be called --act-like-other-vcses).  Commit both staged
    (i.e. explictly marked as ready for commit) changes and unstaged
    changes.

    Incompatible with explicitly specifying files to commit on the command
    line, and incompatible with the --staged option.

  -b|--bypass-untracked-check
    Commit local changes, even if there are untracked files around.

  --staged|-d|--dirty
    Commit only staged changes and bypass sanity checks.  (\"dirty\" is kept
    as a synonym in order to provide a short (-d) form.  The term \"dirty\"
    is used to convey the fact that the working area will likely not be
    \"clean\" after a commit since unstaged changes will still be present).

    WARNING: Do not try to use -s as a shorthand for --staged; -s has a
    different meaning (see 'git commit --help')

    Incompatible with explicitly specifying files to commit on the command
    line, and incompatible with the --all-tracked option.

  -F <file>
    Use the contents of <file> as the commit message

  -m <msg>
    Use <msg> as the commit message.

  --amend
    Amend the last commit on the current branch.
";
  $self->{'differences'} = '
  The "--staged" (and "-d" and "--dirty" aliases) are unique to eg commit;
  git commit behavior differs from eg commit in that it acts by default
  like the --staged flag was passed UNLESS either the -a option is passed
  or files are explicitly listed on the command line.

  The "-b" and "--bypass-untracked-check" are unique to eg commit; git
  commit behavior differs by always turning on this functionality -- there
  is no way to have git commit do an untracked files sanity check for you.
  Yes, I know I need to add a configuration option to make this the default
  in eg commit too.  I am just utterly sick of people forgetting to commit
  new files they create...

  "-a" is not nearly as useful for eg commit as it is for git commit.  "-a"
  has the same behavior in both, but the "smart" behavior of eg commit
  means it is only rarely needed.

  The "--all-tracked" alias for "-a" is known as "--all" to git-commit; I
  find the latter confusing and misleading and thus renamed to the former
  for eg commit.
';
  return $self;
}

sub preprocess {
  my $self = shift;
  my $package_name = ref($self);

  #
  # Parse options
  #
  my ($files, $opts, $revs) = Util::git_rev_parse(@ARGV);
  my ($all_tracked, $bypass_untracked, $staged) = (0, 0, 0);
  my $result = main::GetOptions(
    "--help"                      => sub { $self->help() },
    "all-tracked|a"               => \$all_tracked,
    "bypass-untracked-check|b"    => \$bypass_untracked,
    "staged|staged|d"             => \$staged,
    );

  #
  # Set up flags based on options, do sanity checking of options
  #
  my ($check_untracked, $check_mixed);
  $self->{'commit_flags'} = "";
  die "Cannot specify both --all-tracked (-a) and --staged (-d)!\n" if
    $all_tracked && $staged;
  die "Cannot specify --staged when specifying files!\n" if @$files && $staged;
  $check_untracked = !$bypass_untracked && !$staged && !@$files;
  $check_mixed     = !$all_tracked      && !$staged && !@$files;
  $self->{'commit_flags'} .= " -a" if $all_tracked;

  #
  # Lots of sanity checks
  #
  my $status = RepoUtil::commit_checks($package_name,
                                       {no_changes       => 1,
                                        untracked        => $check_untracked,
                                        partially_staged => $check_mixed});
  if (!$all_tracked && 
      $status->{has_unstaged_changes} && !$status->{has_staged_changes}) {
    $self->{'commit_flags'} .= " -a";
  }

  push(@ARGV, $self->{'commit_flags'}) if $self->{'commit_flags'};
}

###########################################################################
# diff                                                                    #
###########################################################################
package diff;
@diff::ISA = qw(subcommand);
INIT {
  $command{diff} = {
    section => 'discovery',
    about => 'Show changes to file contents'
    };
}

sub new {
  my $class = shift;
  my $self = $class->SUPER::new();
  bless($self, $class);
  $self->{'help'} = "
Usage:
  eg diff [--unstaged|--staged] [<commit>] [<commit>]

Description:
  Shows differences between different versions of the project.  By default,
  it shows the differences between the last locally recorded version and the
  version in the working copy.

Examples:
  Show local unrecorded changes
      \$ eg diff

  In a project with the current branch being 'master', show the differences
  between the version before the last recorded commit and the working copy.
      \$ eg diff master~1
  Or do the same using \"HEAD\" which is a synonym for the current branch:
      \$ eg diff HEAD~1

  Show changes between 10 versions before last recorded commit and the last
  recorded commit (assumes the current branch is 'master').
      \$ eg diff master~10 master

  (Advanced) Show changes between staged (ready-to-be-committed) version of
  files and the working copy (use 'eg add' to stage files).  In other
  words, show the unstaged changes.
      \$ eg diff --unstaged

  (Advanced) Show changes between last recorded copy and the staged (ready-
  to-be-committed) version of files (use 'eg add' to stage files).  In
  other words, show the staged changes.
      \$ eg diff --staged

  (Advanced) Show changes between 5 versions before the last recorded
  commit and the currently staged (ready-to-be-committed) version of the
  repository.  (Use 'eg add' to stage files).
      \$ eg diff --staged HEAD~5

Options:
  <commit>
    A reference to a recorded version of the repository.  Valid versions
    are typically of the form <branch> or <branch>~<n>, though 40-character
    hexadecimal \"commit identifiers\" are allowed too.  See the 'commit'
    line in the output of 'eg log' for examples.

  --staged|--cached
    Show changes between the last commit and the staged copy of files.
    Cannot be used when two <commit>s have been specified.

  --unstaged
    Show changes between the staged copy of files and the current working
    directory.  Cannot be used when a <commit> is specified.
";
  $self->{'differences'} = '
  The following illustrate the two changed defaults of eg diff:
    eg diff            <=> git diff HEAD
    eg diff --unstaged <=> git diff
  In more detail:

  The "--unstaged" option is unique to eg diff; to get the same behavior
  with git diff you simply list no revisions and omit the "--cached" flag.

  When neither --staged nor --unstaged are specified to eg diff and no
  revisions are given, eg diff will pass along the revision "HEAD" to git
  diff.

  The "--staged" option is an alias for "--cached" unique to eg diff (the
  purpose of the alias is to reduce the number of different names in git
  used to refer to the same concept.)
';
  return $self;
}

sub preprocess {
  my $self = shift;
  my $package_name = ref($self);

  my ($files, $opts, $revs) = Util::git_rev_parse(@ARGV);

  #
  # Parse options
  #
  $self->{'opts'} = "";
  @ARGV = @$opts;
  my ($staged, $unstaged) = (0, 0);
  my $result = main::GetOptions(
    "--help"         => sub { $self->help() },
    "staged|cached"  => \$staged,
    "unstaged"       => \$unstaged,
    );
  die "Cannot specify both --staged and --unstaged!\n" if $staged && $unstaged;
  $self->{'opts'} .= " --cached" if $staged;

  #
  # Parse revs
  #
  die "eg diff: Too many revisions specified.\n" if (scalar @$revs > 2);
  die "eg diff: Cannot specify '--staged' with more than 1 revision.\n"
    if ($staged && scalar @$revs > 1);
  die "eg diff: Cannot specify '--unstaged' with any revisions.\n"
    if ($unstaged && scalar @$revs > 0);
  # 'eg diff' (without arguments) should act like 'git diff HEAD'
  push(@$revs, "HEAD") if (!@$revs && !$unstaged && !$staged);

  @ARGV = "$self->{opts} @$revs @$files"
}

###########################################################################
# help                                                                    #
###########################################################################
package help;
@help::ISA = qw(subcommand);
INIT {
  $command{help} = {
    section => 'misc',
    about => 'Get command syntax and examples'
    };
}

sub new {
  my $class = shift;
  my $self = $class->SUPER::new(exit_status => 0, @_);
  bless($self, $class);
  $self->{'help'} = "
Usage:
  eg help [<subtopic>]

Description:
  Shows general help for eg, for one of its subcommands, or for a
  specialized topic.

Examples:
  Show help for eg
      \$ eg help

  Show help for the switch command of eg
      \$ eg help switch

  Show which topics have available help
      \$ eg help topic

  Show the help for the staging topic
      \$ eg help topic staging
";
  $self->{'differences'} = '
  "git help <command>" simply calls "man git-<command>".  The git man pages
  are really nice for people who are experts with git; they are
  comprehensive and detailed.  However, new users tend to get lost in a sea
  of details and advanced topics (among other problems).  "eg help
  <command>" provides much simpler pages of its own and refers to the
  manpages for more details.  They also list any differences between the eg
  commands and the git ones, to allow users to easily learn git.

  Ignore the lie below about seeing "man git-help" for more details.  The
  help command of eg is completely different than the help command of git.
  ';

  return $self;
}

sub preprocess {
  my $self = shift;
  my $package_name = ref($self);

  my $result=main::GetOptions("--help" => sub { $self->help() });

  # Check if we were asked to get help on a subtopic rather than toplevel help
  if (@ARGV == 1) {
    die "Oops, there's a bug.\n" if $self->{exit_status} != 0;
    my $subcommand = shift @ARGV;

    if (!$subcommand->can("new")) {
      print "$subcommand is not modified by eg.  Will try running 'git help " .
            "$subcommand' in 2\nseconds...\n";
      sleep 2;
      exit ExecUtil::execute("git help $subcommand");
    }

    my $subcommand_obj = $subcommand->new();
    $subcommand_obj->help();
  } elsif (@ARGV > 1) {
    $self->{exit_status} = 1;
    print STDERR "Too many arguments to help.\n";
  }

  # Print valid subcommands sorted by section
  foreach my $name (sort
                    {$section->{$a}{'order'} <=> $section->{$b}{'order'}}
                    keys %$section) {
    print "$section->{$name}{desc}\n";
    foreach my $c (sort keys %command) {
      next if $command{$c}{section} ne $name;
      printf "  eg %-15s %s\n", $c, $command{$c}{about};
    }
    print "\n";
  }

  # Check to see if someone added a command with an invalid section
  my $broken_commands = "";
  foreach my $c (keys %command) {
    next if defined $section->{$command{$c}{section}};
    printf "    -%15s %s\n", $c, $command{$c}{about};
  }
  if ($broken_commands) {
    print "Broken (typo in classification?) commands:\n$broken_commands";
  }

  # And let them know how to get more detailed help...
  print "Type 'eg help <command>' to get more help on <command>.\n";
  
  exit $self->{exit_status};
}

###########################################################################
# log                                                                     #
###########################################################################
package log;
@log::ISA = qw(subcommand);
INIT {
  $command{log} = {
    section => 'discovery',
    about => 'Show history of recorded changes'
    };
}

sub new {
  my $class = shift;
  my $self = $class->SUPER::new();
  bless($self, $class);
  $self->{'help'} = "
Usage:
  eg log

Description:
  Shows a history of recorded changes.  Displays commit identifiers,
  the authors of the changes, and commit messages.
";
  $self->{'differences'} = '
  eg log output differs from git log output by showing simpler revision
  identifiers that will be easier for new users to understand and use.
  In detail:
    eg log
  is the same as
    git log | git name-rev --stdin --refs=$(git symbolic-ref HEAD) | less

  If I could figure out how to make git log show references relative to
  "HEAD" when not working on any (named) branch (i.e. "when the HEAD is
  detached", to put it in gitspeak), I would do that too.  Unfortunately, I
  have not figured that out yet.
  ';
  return $self;
}

sub run {
  my $head_ref=RepoUtil::current_branch();
  chomp($head_ref);
  open(INPUT, "git log @ARGV | git name-rev --stdin --refs=$head_ref |");
  open(OUTPUT, "| less");
  while (<INPUT>) {
    print OUTPUT;
  }
  close(INPUT);
  close(OUTPUT);
}

###########################################################################
# status                                                                  #
###########################################################################
package status;
@status::ISA = qw(subcommand);
INIT {
  $command{status} = {
    section => 'discovery',
    about => 'Summarize current changes'
    };
}

sub new {
  my $class = shift;
  my $self = $class->SUPER::new();
  bless($self, $class);
  $self->{'help'} = "
Usage:
  eg status

Description:
  Show the current state of the project.  In addition to showing the
  currently active branch, this command will list files with content in any
  of the following states:

     Untracked
       Files that are not explicitly ignored (i.e. do not appear in an
       ignore list such as a .gitignore file) but whose contents are still
       not tracked by git.

       These files can become tracked by running 'eg add <filename>', or
       ignored by having their name added to a .gitignore file.

     Changed but not updated (\"unstaged\")
       Files whose contents have been modified in the working copy.

       (Advanced usage note) If you explicitly mark all the changes in a
       file as ready to be committed, then the file will not appear in this
       list and will instead appear in the \"staged\" list (see below).
       However, a file can appear in both the unstaged and staged lists if
       only part of the changes in the file are marked as ready for commit.

     Changes ready to be committed (\"staged\")
       Files with content changes that have explicitly been marked as ready
       to be committed.  This state only typically appears in advanced
       usage.

       Files enter this state through the use of 'eg add'.  Files can
       return to the unstaged state by running 'eg reset HEAD <file>'.  See
       'eg help topic staging' to learn about the staging area.
";
  $self->{'differences'} = '
  eg status output is essentially just a streamlined and cleaned version of
  git status output.  The streamlining serves to avoid information overload
  to new users (which is only possible with a less error prone "commit"
  command) and the cleaning (removal of leading hash marks) serves to make
  the system more inviting to new users.  There are slight changes to the
  section names to reinforce consistent naming when referring to the same
  concept, but the changes are very slight.
  ';
  return $self;
}

sub postprocess {
  my $self = shift;
  my $output = shift;

  my $branch;
  my %files = ( untracked => undef, unstaged => undef, staged => undef );

  my @lines = split('\n', $output);
  my $cur_state = 0;
  while (@lines) {
    my $line = shift @lines;
    my $section = undef;

    if ($line =~ m/^# On branch (.*)$/) {
      $branch = $1;
    } elsif ($line =~ m/^# Untracked files:$/) {
      $cur_state = 1;
      $section = 'untracked';
      $title = "Untracked files:";
    } elsif ($line =~ m/^# Changes to be committed:$/) {
      $cur_state = 2;
      $section = 'staged';
      $title = 'Changes ready to be committed ("staged"):';
    } elsif ($line =~ m/^# Changed but not updated:$/) {
      $cur_state = 2;
      $section = 'unstaged';
      $title = 'Changed but not updated ("unstaged"):';
    }

    # If we're inside a section type, parse it
    if ($cur_state > 0) {
      my @section_files;
      my $hint = shift @lines;
      shift @lines; # Get rid of blank line

      $line = shift @lines;
      while (defined $line && $line =~ m/^#.+$/) {
        if ($cur_state == 1) {
          if ($line =~ m/^#(\s+)(.*)/) { 
            my $file = $2;
            push @section_files, "$1$file";
          }
        } elsif ($cur_state == 2) {
          if ($line =~ m/^#(\s+.*:\s+)(.*)/) {
            my $file = $2;
            push(@section_files, "$1$file");
          }
        }
        $line = shift @lines;
      }

      if (defined($files{$section})) {
        push(@{$files{$section}{'file_list'}}, @section_files);
      } else {
        $files{$section} = { title     => $title,
                             hint      => $hint,
                             file_list => \@section_files };
      }

      # Record that we finished parsing this section
      $cur_state = 0;
    }
  }

  # Print out the branch we are on
  print "(On branch $branch)\n";

  # Print out all the various changes
  foreach my $section (sort keys %files) {
    if (defined($files{$section})) {
      print "$files{$section}{'title'}\n";
      foreach my $fileline (@{$files{$section}{'file_list'}}) {
        print "$fileline\n";
      }
    }
  }

}



#*************************************************************************#
#*************************************************************************#
#*************************************************************************#
#                             UTILITY CLASSES                             #
#*************************************************************************#
#*************************************************************************#
#*************************************************************************#

###########################################################################
# ExecUtil                                                                #
###########################################################################
package ExecUtil;

# _execute_impl is the guts for execute() and execute_captured()
sub _execute_impl {
  my ($command, @opts) = @_;
  my ($ret, $output);
  my %options = ( ignore_ret => 0, capture_output => 0, @opts );

  if ($verbose) {
    print "eg: running >>$command<<";
    print "\n";
  }

  #
  # Execute the relevant command, in a subdirectory if needed, and capturing
  # stdout and stderr if wanted
  #
  if ($options{capture_output}) {
    $output = `$command 2>&1`;
    $ret = $?;
  } elsif (defined $outfh) {
    open(OUTPUT, "$command 2>&1 |");
    while (<OUTPUT>) {
      print $outfh $_;
    }
    close(OUTPUT);
    $ret = $?;
  } else {
    system($command);
    $ret = $?;
  }

  #
  # Determine retval
  #
  if ($ret != 0) {
    if (($? & 127) == 2) {
      print STDERR "eg: interrupted\n";
    }
    elsif ($? & 127) {
      print STDERR "eg: received signal ".($? & 127)."\n";
    }
    elsif (! $options{ignore_ret}) {
      print STDERR "eg: failed ($ret)\n" if $verbose;
      if ($ret >> 8 != 0) {
        print STDERR "eg: command ($command) failed\n";
      }
      elsif ($ret != 0) {
        print STDERR "eg: command ($command) died (retval=$ret)\n";
      }
    }
  }

  return $options{capture_output} ? ($ret, $output) : $ret;
}

# executes a command, capturing its output (both STDOUT and STDERR)
sub execute_captured {
  my ($command, @options) = @_;
  return _execute_impl($command, capture_output => 1, @options);
}

# executes a command (output not captured)
sub execute {
  my ($command, @options) = @_;
  return _execute_impl($command, @options);
}

###########################################################################
# RepoUtil                                                                #
###########################################################################
package RepoUtil;

# Return whether or not there are uncommitted changes in the repository.
# Only counts staged changes, unless the -a flag is passed as an argument
sub uncommitted_changes {
  my $flags = shift;

  $flags = "" if !defined $flags;

  my $ret = ExecUtil::execute("git status $flags > /dev/null",
                              ignore_ret => 1);
  # $ret == 0 => there are uncommitted changes.  $ret == 1 => opposite
  return !$ret;
}

# current_branch: Get the currently active branch
sub current_branch {
  my ($ret, $output) = ExecUtil::execute_captured("git symbolic-ref HEAD");
  return undef if $ret != 0;
  chomp($output);
  return $output;
}

sub commit_checks {
  my ($commit_type, $check_for) = @_;
  my %status;

  my ($ret, $output) = ExecUtil::execute_captured("eg status");
  $status{has_untracked_files}  = ($output =~ /^Untracked files:$/m);
  $status{has_unstaged_changes} = ($output =~ /^Changed but not updated/m);
  $status{has_staged_changes}   = ($output =~ /^Changes ready to be commit/m);
  $status{has_no_changes}       =
    ($output =~ /^nothing to commit \(working directory clean\)\n\z/m);

  if ($check_for->{no_changes} && $status{has_no_changes}) {
    print STDERR "Aborting: Nothing to commit (run 'eg status' for details).\n";
    exit 1;
  }
  elsif ($check_for->{untracked} && $check_for->{partially_staged} &&
         $status{has_untracked_files} && 
         $status{has_unstaged_changes} && $status{has_staged_changes}) {
    print STDERR <<EOF;
Aborting: It is not clear which changes should be committed; you have
untracked files, staged (explictly marked as ready for commit) changes, and
unstaged changes all present.  Run 'eg help $commit_type' for details.
EOF
    exit 1;
  }
  elsif ($check_for->{untracked} && $status{has_untracked_files}) {
    print STDERR <<EOF;
Aborting: You have untracked files present and it is not clear whether
they should be committed.  Run 'eg help $commit_type' for details.
EOF
    exit 1;
  }
  elsif ($check_for->{partially_staged} &&
         $status{has_unstaged_changes} && $status{has_staged_changes}) {
    print STDERR <<EOF;
Aborting: It is not clear which changes should be committed; you have both
staged (explictly marked as ready for commit) changes and unstaged changes
present.  Run 'eg help $commit_type' for details.
EOF
    exit 1;
  }

  if ($check_for->{has_tabs}) {
    my $diff_flags = "--staged";
    if ($status{has_unstaged_changes} && !$status{has_staged_changes}) {
      $diff_flags = "";
    }

    ($ret, $output) = ExecUtil::execute_captured("eg diff $diff_flags");
    $status{has_tabs_added} = ($output =~ /^\+.*\t/m);

    if ($status{has_tabs_added}) {
      print STDERR
        "Your changes (see output of 'eg diff $diff_flags') include tabs\n" .
        "in the added lines (or new version of the changed lines).  Please\n" .
        "remove them before committing.\n";
      exit 1;
    }
  }

  return \%status;
}


###########################################################################
# Util                                                                    #
###########################################################################
package Util;

# Return items in @$lista but not in @$listb
sub difference {
  my ($lista, $listb) = @_;
  my %count;

  foreach my $item (@$lista) { $count{$item}++ };
  foreach my $item (@$listb) { $count{$item}-- };

  my @ret = grep { $count{$_} == 1 } keys %count;
}

# Have git's rev-parse command parse @args and decide which part is files,
# which is options, and which are revisions.  Further, have git translate
# revisions into full 40-character hexadecimal commit ids.
sub git_rev_parse {
  my @args = @_;

  my ($ret, $output) = 
    ExecUtil::execute_captured("git rev-parse @ARGV", ignore_ret => 1);
  if ($ret != 0) {
    $output =~ /^(fatal:.*)$/m   && print STDERR "$1\n";
    $output =~ /^(Use '--'.*)$/m && print STDERR "$1\n";
    exit 1;
  }
  my @files = split('\n', `git rev-parse --no-revs --no-flags @ARGV`);
  my @opts  = split('\n', `git rev-parse --no-revs --flags    @ARGV`);
  my @revs  = split('\n', `git rev-parse --revs-only          @ARGV`);

  return (\@files, \@opts, \@revs);
}



#*************************************************************************#
#*************************************************************************#
#*************************************************************************#
#                              MAIN PROGRAM                               #
#*************************************************************************#
#*************************************************************************#
#*************************************************************************#

package main;

sub launch {
  my $job=shift;

  my $action;
  $action = $job->new()                      if  $job->can("new");
  $action = subcommand->new(command => $job) if !$job->can("new");
  $action->preprocess() if $action->can("preprocess");

  if (!$action->can("postprocess")) {
    $action->run();
  } else {
    my $output = "";
    open($outfh, '>', \$output) || die "eg $job: cannot open \$outfh: $!";
    $action->run();
    $action->postprocess($output);
  }

  # Do any wrapup required
  $action->wrapup() if $action->can("wrapup");;
}

sub version {
  print "eg version $version\n";
  exit 0;
}

# User gave invalid input; print an error_message, then show command usage
sub help {
  my $error_message = shift;
  my %extra_args;

  # Clear out any arguments so that help object doesn't think we asked for
  # a specific help topic.
  @ARGV = ();

  # Print any error message we were given
  if (defined $error_message) {
    print STDERR "$error_message\n\n";
    $extra_args{exit_status} = 1;
  }

  # Now show help.
  my $help_obj = "help"->new(%extra_args);
  $help_obj->run();
}

sub main {
  #
  # Get any global options 
  #
  Getopt::Long::Configure("no_bundling", "no_permute", "pass_through");
  my $result=GetOptions(
               "--help"    => sub { help() },
               "--verbose" => \$verbose,
               "--version" => sub { version() },
                        );
  help("eg: Error parsing arguments.") if !$result;
  help("eg: No subcommand specified.") if @ARGV < 1;

  #
  # Set up an interrupt signal handler
  #
  $SIG{INT}=sub {
    print STDERR "eg: interrupted\n";
    exit 2;
  };

  #
  # Now execute the action
  #
  my $action = shift @ARGV;
  launch($action);
}

main();
