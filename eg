#!/usr/bin/perl

## Easy GIT (eg), a usable version of git.
## Copyright 2008 by Elijah Newren
## Licensed under GNU GPL, version 2.

package main;

use warnings;
use Getopt::Long;
use List::Util qw(min max);

# configurables
my $verbose=0;

# globals :-(
my $outfh;
my $version = "0.5.4.alphabeticalcharactersdontbelonginversionnumbers";
my %command;    # command=>{section, short_description} mapping
my $section = {
  'creation' =>
    { order => 1,
      desc  => 'Creating repositories',
    },
  'discovery' =>
    { order => 2,
      desc  => 'Obtaining information about changes, history, & state',
    },
  'modification' =>
    { order => 3,
      desc  => 'Making, undoing, or recording changes',
    },
  'projects' =>
    { order => 4,
      desc  => 'Managing branches',
    },
  'collaboration' =>
    { order => 5,
      desc  => 'Collaboration'
    },
  'timesavers' =>
    { order => 6,
      desc  => 'Time saving commands'
    },
  'compatibility' =>
    { order => 7,
      extra => 1,
      desc  => 'Commands provided for compatibility with other SCMs'
    },
  'misc' =>
    { order => 8,
      desc  => 'Miscellaneous'
    },
  };
## Commands to list in help even though we haven't overridden the git versions
INIT {
  %command = (
    blame => {
      extra => 1,
      section => 'discovery',
      about => 'Show what version and author last modified each line of a file'
      },
    bisect => {
      section => 'timesavers',
      about => 'Find the change that introduced a bug by binary search'
      },
    clone => {
      section => 'creation',
      about => 'Clone a repository into a new directory'
      },
    grep => {
      extra => 1,
      section => 'discovery',
      about => 'Print lines of tracked files matching a pattern'
      },
    init => {
      section => 'creation',
      about => 'Create a new empty repository'
      },
    merge => {
      section => 'projects',
      about => 'Join two or more development histories (branches) together'
      },
    mv => {
      section => 'modification',
      about => 'Move or rename files (or directories or symlinks)'
      },
    pull => {
      section => 'collaboration',
      about => 'Get updates from another repository and merge them'
      },
    push => {
      section => 'collaboration',
      about => 'Update a remote mirror of the local repository'
      },
    rebase => {
      extra => 1,
      section => 'timesavers',
      about => "Port local commits, making them be based on a different\n" .
               "                repository version"
      },
    rm => {
      extra => 1,
      section => 'modification',
      about => 'Remove files'
      },
    stash => {
      section => 'timesavers',
      about => 'Save and revert local changes, or apply stashed changes',
      },
    tag => {
      extra => 1,
      section => 'modification',
      about => 'Provide a name for a specific version of the repository'
      },
  );
}



#*************************************************************************#
#*************************************************************************#
#*************************************************************************#
#                   CLASSES DEFINING ACTIONS TO PERFORM                   #
#*************************************************************************#
#*************************************************************************#
#*************************************************************************#

###########################################################################
# subcommand, a base class for all eg subcommands                         #
###########################################################################
package subcommand;
sub new {
  my $class = shift;
  my $self = {@_};  # Hashref initialized as we're told
  bless($self, $class);

  # Our "see also" section in help usually references the same subsection
  # as our class name.
  $self->{git_equivalent} = ref($self) if !defined $self->{git_equivalent};

  # We allow direct instantiation of the subcommand class only if they
  # provide a command name for us to pass to git.
  if (ref($class) eq "subcommand" && !defined $self->{command}) {
    die "Invalid subcommand usage"
  }

  return $self;
}

sub help {
  my $self = shift;
  my $package_name = ref($self);
  my $git_equiv = $self->{git_equivalent};

  if ($package_name eq "subcommand") {
    exit ExecUtil::execute("git $self->{command} --help")
  }

  open(OUTPUT, "|less");
  print OUTPUT "$package_name: $command{$package_name}{about}\n";
  print OUTPUT $self->{'help'};
  print OUTPUT "\nDifferences from git $package_name:";
  print OUTPUT "\n  None.\n" if !defined $self->{'differences'};
  print OUTPUT $self->{'differences'} if defined $self->{'differences'};
  if ($git_equiv) {
    print OUTPUT "\nSee also\n";
    print OUTPUT <<EOF;
    Run 'man git-$git_equiv' for a comprehensive list of options available.
    eg $package_name is designed to accept the same options with the same
    meanings (unless specified otherwise in the above "Differences" section).
EOF
  }
  close(OUTPUT);
  exit 0;
}

sub preprocess {
  my $self = shift;

  my $result=main::GetOptions("--help" => sub { $self->help() });
}

sub run {
  my $self = shift;
  my $package_name = ref($self);

  my $subcommand = 
    $package_name eq "subcommand" ? $self->{'command'} : $package_name;

  return ExecUtil::execute("git $subcommand @ARGV", ignore_ret => 1);
}

###########################################################################
# add                                                                     #
###########################################################################
package add;
@add::ISA = qw(subcommand);
INIT {
  $command{add} = {
    section => 'modification',
    about => 'Mark content in files as being ready for commit'
    };
}

sub new {
  my $class = shift;
  my $self = $class->SUPER::new();
  bless($self, $class);
  $self->{'help'} = "
Usage:
  eg add [--] <PATH> ...

Description:
  Marks the contents of the specified files as being ready to commit,
  scheduling them for addition to the repository.  (This is also known as
  staging.)  When a directory is passed, all files in that directory or any
  subdirectory are recursively added.

Examples:
  Create a new file, and mark it for addition to the repository.
      \$ echo hi > there
      \$ eg add there

  (Advanced) Mark some changes as good, add some verbose sanity checking code,
  then commit just the good changes.
      Implement some cool new feature in somefile.C
      \$ eg add somefile.C
      Add some verbose sanity checking code to somefile.C
      Decide to commit the new feature code but not the sanity checking code:
      \$ eg commit --staged

  (Advanced) Show changes in a file, split by those that you have marked as
  good and those that you haven't:
      Make various edits
      \$ eg add file1 file2
      Make more edits, include some to file1
      \$ eg diff            # Look at all the changes
      \$ eg diff --staged   # Look at the \"ready to be committed\" changes
      \$ eg diff --unstaged # Look at the changes not ready to be commited

Options:
  --
    This option can be used to separate command-line options from the list
    of files, (useful when filenames might be mistaken for command-line
    options).
";
  return $self;
}

###########################################################################
# branch                                                                  #
###########################################################################
package branch;
@branch::ISA = qw(subcommand);
INIT {
  $command{branch} = {
    section => 'projects',
    about => 'List, create, or delete branches'
    };
}

sub new {
  my $class = shift;
  my $self = $class->SUPER::new();
  bless($self, $class);
  $self->{'help'} = "
Usage:
  eg branch [-r]
  eg branch <branchname> [<startpoint>]
  eg branch -d <branchname>

Description:
  List the existing branches that you can switch to, create a new (local)
  branch, or delete an existing (local) branch.

  Note that creation of branches in a remote repository can be accomplished
  by first creating a local branch and then pushing your changes to the
  remote repository using eg push.

Examples
  List the available local branches
      \$ eg branch

  Create a new local branch named random_stuff, based off the last commit.
      \$ eg branch random_stuff

  Create a new local branch named sec_48 based off the local 4.8 branch
      \$ eg branch sec_48 4.8

  Create a new local branch named bling, based off the remote branch of the
  same name (see 'eg help topic storage' for more details)
      \$ eg branch bling origin/bling

  Delete the local branch named bling
      \$ eg branch -d bling

Options:
  -d
    Delete specified branch

  -r
    List remote tracking branches (see 'eg help topic storage') for
    more details.
";
  return $self;
}

###########################################################################
# commit                                                                  #
###########################################################################
package commit;
@commit::ISA = qw(subcommand);
INIT {
  $command{commit} = {
    section => 'modification',
    about => 'Record changes locally'
    };
  $alias{'checkin'} = "commit";
  $alias{'ci'}      = "commit";
}

sub new {
  my $class = shift;
  my $self = $class->SUPER::new();
  bless($self, $class);
  $self->{'help'} = "
Usage:
  eg commit [-a|--all-tracked] [-b|--bypass-untracked-check]
            [--staged|-d|--dirty] [-F <file> | -m <msg> | --amend]
            [--] [<file>...]

Description:
  Records changes locally along with a log message describing the
  changes you have made.  If no -F or -m option is supplied, an editor
  is opened for you to enter a log message.

  In order to prevent common errors, the commit will abort with a warning
  message if there are no changes to commit or if it detects that the
  choice of what to commit is ambiguous.  In particular, if you have any
  untracked files present, or if you have both staged changes (i.e. changes
  explicitly marked as ready for commit) and unstaged changes, then you
  will get a warning rather than having the commit occur.  You can run 'eg
  status' to get the status of various files and their changes.  These
  commit checks can be bypassed with various options.

Examples:
  Record current changes locally, not changing anything in CVS...OR...get
  a warning message if eg detects that the choice of what to commit is not
  necessarily clear.
      \$ eg commit

  Record current changes, ignoring any untracked files present.
      \$ eg commit -b

  Record brand new file and current changes.
      \$ eg add file.c
      \$ eg commit -a
  Note: Running 'eg add <file>' explicitly marks <file> as being ready to
  commit.  Since you likely haven't explicitly marked your other changes as
  ready to commit, pass the -a flag to specify that both kinds of changes
  should be recorded.

  (Advanced) Record staged changes, ignoring both unstaged changes and
  untracked files.
      \$ eg commit --staged

Options:
  -a|--all-tracked
    (Could also be called --act-like-other-vcses).  Commit both staged
    (i.e. explictly marked as ready for commit) changes and unstaged
    changes.

    Incompatible with explicitly specifying files to commit on the command
    line, and incompatible with the --staged option.

  -b|--bypass-untracked-check
    Commit local changes, even if there are untracked files around.

  --staged|-d|--dirty
    Commit only staged changes and bypass sanity checks.  (\"dirty\" is kept
    as a synonym in order to provide a short (-d) form.  The term \"dirty\"
    is used to convey the fact that the working area will likely not be
    \"clean\" after a commit since unstaged changes will still be present).

    WARNING: Do not try to use -s as a shorthand for --staged; -s has a
    different meaning (see 'git commit --help')

    Incompatible with explicitly specifying files to commit on the command
    line, and incompatible with the --all-tracked option.

  -F <file>
    Use the contents of <file> as the commit message

  -m <msg>
    Use <msg> as the commit message.

  --amend
    Amend the last commit on the current branch.
";
  $self->{'differences'} = '
  The "--staged" (and "-d" and "--dirty" aliases) are unique to eg commit;
  git commit behavior differs from eg commit in that it acts by default
  like the --staged flag was passed UNLESS either the -a option is passed
  or files are explicitly listed on the command line.

  The "-b" and "--bypass-untracked-check" are unique to eg commit; git
  commit behavior differs by always turning on this functionality -- there
  is no way to have git commit do an untracked files sanity check for you.
  Yes, I know I need to add a configuration option to make this the default
  in eg commit too.  I am just utterly sick of people forgetting to commit
  new files they create...

  "-a" is not nearly as useful for eg commit as it is for git commit.  "-a"
  has the same behavior in both, but the "smart" behavior of eg commit
  means it is only rarely needed.

  The "--all-tracked" alias for "-a" is known as "--all" to git-commit; I
  find the latter confusing and misleading and thus renamed to the former
  for eg commit.
';
  return $self;
}

sub preprocess {
  my $self = shift;
  my $package_name = ref($self);

  #
  # Parse options
  #
  my ($files, $opts, $revs) = Util::git_rev_parse(@ARGV);
  my ($all_tracked, $bypass_untracked, $staged) = (0, 0, 0);
  my $result = main::GetOptions(
    "--help"                      => sub { $self->help() },
    "all-tracked|a"               => \$all_tracked,
    "bypass-untracked-check|b"    => \$bypass_untracked,
    "staged|staged|d"             => \$staged,
    );

  #
  # Set up flags based on options, do sanity checking of options
  #
  my ($check_untracked, $check_mixed);
  $self->{'commit_flags'} = "";
  die "Cannot specify both --all-tracked (-a) and --staged (-d)!\n" if
    $all_tracked && $staged;
  die "Cannot specify --staged when specifying files!\n" if @$files && $staged;
  $check_untracked = !$bypass_untracked && !$staged && !@$files;
  $check_mixed     = !$all_tracked      && !$staged && !@$files;
  $self->{'commit_flags'} .= " -a" if $all_tracked;

  #
  # Lots of sanity checks
  #
  my $status = RepoUtil::commit_checks($package_name,
                                       {no_changes       => 1,
                                        untracked        => $check_untracked,
                                        partially_staged => $check_mixed});
  if (!$all_tracked && 
      $status->{has_unstaged_changes} && !$status->{has_staged_changes}) {
    $self->{'commit_flags'} .= " -a";
  }

  push(@ARGV, $self->{'commit_flags'}) if $self->{'commit_flags'};
}

###########################################################################
# diff                                                                    #
###########################################################################
package diff;
@diff::ISA = qw(subcommand);
INIT {
  $command{diff} = {
    section => 'discovery',
    about => 'Show changes to file contents'
    };
}

sub new {
  my $class = shift;
  my $self = $class->SUPER::new();
  bless($self, $class);
  $self->{'help'} = "
Usage:
  eg diff [--unstaged|--staged] [<commit>] [<commit>]

Description:
  Shows differences between different versions of the project.  By default,
  it shows the differences between the last locally recorded version and the
  version in the working copy.

Examples:
  Show local unrecorded changes
      \$ eg diff

  In a project with the current branch being 'master', show the differences
  between the version before the last recorded commit and the working copy.
      \$ eg diff master~1
  Or do the same using \"HEAD\" which is a synonym for the current branch:
      \$ eg diff HEAD~1

  Show changes between 10 versions before last recorded commit and the last
  recorded commit (assumes the current branch is 'master').
      \$ eg diff master~10 master

  (Advanced) Show changes between staged (ready-to-be-committed) version of
  files and the working copy (use 'eg add' to stage files).  In other
  words, show the unstaged changes.
      \$ eg diff --unstaged

  (Advanced) Show changes between last recorded copy and the staged (ready-
  to-be-committed) version of files (use 'eg add' to stage files).  In
  other words, show the staged changes.
      \$ eg diff --staged

  (Advanced) Show changes between 5 versions before the last recorded
  commit and the currently staged (ready-to-be-committed) version of the
  repository.  (Use 'eg add' to stage files).
      \$ eg diff --staged HEAD~5

Options:
  <commit>
    A reference to a recorded version of the repository.  Valid versions
    are typically of the form <branch> or <branch>~<n>, though 40-character
    hexadecimal \"commit identifiers\" are allowed too.  See the 'commit'
    line in the output of 'eg log' for examples.

  --staged|--cached
    Show changes between the last commit and the staged copy of files.
    Cannot be used when two <commit>s have been specified.

  --unstaged
    Show changes between the staged copy of files and the current working
    directory.  Cannot be used when a <commit> is specified.
";
  $self->{'differences'} = '
  The following illustrate the two changed defaults of eg diff:
    eg diff            <=> git diff HEAD
    eg diff --unstaged <=> git diff
  In more detail:

  The "--unstaged" option is unique to eg diff; to get the same behavior
  with git diff you simply list no revisions and omit the "--cached" flag.

  When neither --staged nor --unstaged are specified to eg diff and no
  revisions are given, eg diff will pass along the revision "HEAD" to git
  diff.

  The "--staged" option is an alias for "--cached" unique to eg diff (the
  purpose of the alias is to reduce the number of different names in git
  used to refer to the same concept.)
';
  return $self;
}

sub preprocess {
  my $self = shift;
  my $package_name = ref($self);

  my ($files, $opts, $revs) = Util::git_rev_parse(@ARGV);

  #
  # Parse options
  #
  $self->{'opts'} = "";
  @ARGV = @$opts;
  my ($staged, $unstaged) = (0, 0);
  my $result = main::GetOptions(
    "--help"         => sub { $self->help() },
    "staged|cached"  => \$staged,
    "unstaged"       => \$unstaged,
    );
  die "Cannot specify both --staged and --unstaged!\n" if $staged && $unstaged;
  $self->{'opts'} .= " --cached" if $staged;

  #
  # Parse revs
  #
  die "eg diff: Too many revisions specified.\n" if (scalar @$revs > 2);
  die "eg diff: Cannot specify '--staged' with more than 1 revision.\n"
    if ($staged && scalar @$revs > 1);
  die "eg diff: Cannot specify '--unstaged' with any revisions.\n"
    if ($unstaged && scalar @$revs > 0);
  # 'eg diff' (without arguments) should act like 'git diff HEAD'
  push(@$revs, "HEAD") if (!@$revs && !$unstaged && !$staged);

  @ARGV = "$self->{opts} @$revs @$files"
}

###########################################################################
# gc                                                                      #
###########################################################################
package gc;
@gc::ISA = qw(subcommand);
INIT {
  $command{gc} = {
    extra => 1,
    section => 'timesavers',
    about => 'Optimize the local repository to make later operations faster',
    };
}

sub new {
  my $class = shift;
  my $self = $class->SUPER::new();
  bless($self, $class);
  $self->{'help'} = "
Usage:
  eg gc

Description:
  Optimizes the local repository; in particular, this command compresses
  file revisions to reduce disk space and increase performance.

  This command is occasionally called during normal git usage, making
  explicit usage of this command unnecessary for many users.  However, the
  automatic calls of this command only do simple and quick optimizations,
  so some users (particularly those with many revisions) may benefit from
  manually invoking this command periodically (such as from nightly or
  weekly cron scripts).
";
  return $self;
}

###########################################################################
# help                                                                    #
###########################################################################
package help;
@help::ISA = qw(subcommand);
INIT {
  $command{help} = {
    section => 'misc',
    about => 'Get command syntax and examples'
    };
}

sub new {
  my $class = shift;
  my $self = $class->SUPER::new(exit_status => 0, @_);
  bless($self, $class);
  $self->{'help'} = "
Usage:
  eg help [<command>]
  eg help topic [<topic>]

Description:
  Shows general help for eg, for one of its subcommands, or for a
  specialized topic.

Examples:
  Show help for eg
      \$ eg help

  Show help for the switch command of eg
      \$ eg help switch

  Show which topics have available help
      \$ eg help topic

  Show the help for the staging topic
      \$ eg help topic staging
";
  $self->{'differences'} = '
  "git help <command>" simply calls "man git-<command>".  The git man pages
  are really nice for people who are experts with git; they are
  comprehensive and detailed.  However, new users tend to get lost in a sea
  of details and advanced topics (among other problems).  "eg help
  <command>" provides much simpler pages of its own and refers to the
  manpages for more details.  They also list any differences between the eg
  commands and the git ones, to allow users to easily learn git.

  Ignore the lie below about seeing "man git-help" for more details.  The
  help command of eg is completely different than the help command of git.
  ';

  return $self;
}

sub preprocess {
  my $self = shift;
  my $package_name = ref($self);

  $self->{all} = 0;
  my $result=main::GetOptions("--help" => sub { $self->help() },
                              "--all"  => \$self->{all});
}

sub run {
  my $self = shift;
  my $package_name = ref($self);

  # Check if we were asked to get help on a subtopic rather than toplevel help
  if (@ARGV == 1) {
    die "Oops, there's a bug.\n" if $self->{exit_status} != 0;
    my $subcommand = shift @ARGV;

    if (!$subcommand->can("new")) {
      print "$subcommand is not modified by eg.  Will try running 'git help " .
            "$subcommand' in 2\nseconds...\n";
      sleep 2;
      exit ExecUtil::execute("git help $subcommand");
    }

    my $subcommand_obj = $subcommand->new();
    $subcommand_obj->help();
  } elsif (@ARGV > 1) {
    $self->{exit_status} = 1;
    print STDERR "Too many arguments to help.\n";
  }

  # Print valid subcommands sorted by section
  open(OUTPUT, "|less");
  foreach my $name (sort
                    {$section->{$a}{'order'} <=> $section->{$b}{'order'}}
                    keys %$section) {
    next if $section->{$name}{extra} && !$self->{all};
    print OUTPUT "$section->{$name}{desc}\n";
    foreach my $c (sort keys %command) {
      next if $command{$c}{section} ne $name;
      next if $command{$c}{extra} && !$self->{all};
      printf OUTPUT "  eg %-10s %s\n", $c, $command{$c}{about};
    }
    print OUTPUT "\n";
  }

  # Check to see if someone added a command with an invalid section
  my $broken_commands = "";
  foreach my $c (keys %command) {
    next if defined $section->{$command{$c}{section}};
    printf OUTPUT "    -%10s %s\n", $c, $command{$c}{about};
  }
  if ($broken_commands) {
    print OUTPUT "Broken (typo in classification?) commands:\n" .
                 $broken_commands;
  }

  # And let them know how to get more detailed help...
  print OUTPUT "Additional help:\n";
  print OUTPUT "  eg help <command>  Get more help on <command>.\n";
  print OUTPUT "  eg help --all      List more commands (not really all)\n";
  print OUTPUT "  eg help topic      List specialized help topics.\n";
  close(OUTPUT);
  
  exit $self->{exit_status};
}

###########################################################################
# info                                                                    #
###########################################################################
package info;
@info::ISA = qw(subcommand);
INIT {
  $command{info} = {
    section => 'discovery',
    about => 'Show some basic information about the current repository'
    };
}

sub new {
  my $class = shift;
  my $self = $class->SUPER::new(git_equivalent => '');
  bless($self, $class);
  $self->{'help'} = "
Usage:
  eg info

Description:
  Shows information about the current repository.
";
  $self->{'differences'} = '
  eg info is unique to eg; git does not have a similar command.  It is mostly
  intended to do something nice if svn converts happen to try this command
  out.
  ';
  return $self;
}

sub preprocess {
  my $self = shift;

  die "eg info does not yet accept any arguments.\n" if @ARGV;
}

sub run {
  my $self=shift;

  my $num_files = ExecUtil::output("git ls-tree -r HEAD | wc -l");
  my $num_dirs = ExecUtil::output(
                    "git ls-tree -r --full-name --name-only HEAD " .
                    " | grep '/'" .
                    " | sed -e \"s#\(.*\)/.*#\1#\" " .
                    " | sort " .
                    " | uniq " .
                    " | wc -l");

  my $command = "git ls-tree -r --full-name --name-only HEAD";
  my $size_of_files = "xargs ls -l | awk '{print \$5 \" (\" \$9 \")\"}'";
  my $biggest = "sort -n | tail -n 1";
  my $biggest_file = ExecUtil::output("$command | $size_of_files | $biggest");

  my $total_commits = ExecUtil::output("git rev-list --all | wc -l");;
  my $branch_depth  = ExecUtil::output("git rev-list HEAD | wc -l");;
  my $contributors  = ExecUtil::output("git shortlog -s -n HEAD | wc -l");;
  my $current_branch = ExecUtil::output("git symbolic-ref HEAD |sed -e s#.*/##");
  my $current_commit = ExecUtil::output("git show-ref -s -h | head -n 1");;

  # Other possibilities:
  #   Disk space used by respository (du -hs .git, or packfile size?)
  #   Disk space used by working copy (???)
  #   Somthing about remote tracking branches?

  print "Current commit: $current_commit\n";
  print "Number of contributors: $contributors\n";
  print "Total commits: $total_commits\n";
  print "Current branch: $current_branch\n";
  print "Number of files: $num_files\n";
  print "Number of directories: $num_dirs\n";
  print "Biggest file size (bytes): $biggest_file\n";
  print "Commits in current branch: $branch_depth\n";
}

###########################################################################
# log                                                                     #
###########################################################################
package log;
@log::ISA = qw(subcommand);
INIT {
  $command{log} = {
    section => 'discovery',
    about => 'Show history of recorded changes'
    };
}

sub new {
  my $class = shift;
  my $self = $class->SUPER::new();
  bless($self, $class);
  $self->{'help'} = "
Usage:
  eg log

Description:
  Shows a history of recorded changes.  Displays commit identifiers,
  the authors of the changes, and commit messages.
";
  $self->{'differences'} = '
  eg log output differs from git log output by showing simpler revision
  identifiers that will be easier for new users to understand and use.
  In detail:
    eg log
  is the same as
    git log | git name-rev --stdin --refs=$(git symbolic-ref HEAD) | less

  If I could figure out how to make git log show references relative to
  "HEAD" when not working on any (named) branch (i.e. "when the HEAD is
  detached", to put it in gitspeak), I would do that too.  Unfortunately, I
  have not figured that out yet.
  ';
  return $self;
}

sub run {
  my $head_ref=RepoUtil::current_branch();
  chomp($head_ref);
  open(INPUT, "git log @ARGV | git name-rev --stdin --refs=$head_ref |");
  open(OUTPUT, "| less");
  while (<INPUT>) {
    print OUTPUT;
  }
  close(INPUT);
  close(OUTPUT);
}

###########################################################################
# reset                                                                   #
###########################################################################
package reset;
@reset::ISA = qw(subcommand);
INIT {
  $command{reset} = {
    extra => 1,
    section => 'modification',
    about => 'Forget local commits and (optionally) undo their changes'
    };
}

sub new {
  my $class = shift;
  my $self = $class->SUPER::new();
  bless($self, $class);
  $self->{'help'} = "
Usage:
  eg reset [--working-copy | --no-unstaging] [<commit>]

Description:
  Forgets local commits for the active branch and (optionally) undoes their
  changes in the working copy.  If you have staged changes (changes you
  explictly marked as ready for commit) this function also unstages them by
  default.  See 'eg help topic staging' to learn about the staging area.

  From a computer science point of view, eg reset moves the current branch
  tip pointer to point at an older commit, and also optionally changes the
  working copy and staging area to match the version of the repository
  recorded in the older commit.

  Note that this function should be used with caution; it is often used to
  discard unwanted data or to modify recent local \"history\" of commits.
  You want to be careful to not also discard wanted data, and modifying
  history is a bad idea if someone has already obtained a copy of that
  local history from you (rewriting history makes merging and updating
  problematic).

Examples:
  Throw away all changes since the last commit
      \$ eg reset --working-copy HEAD
  Note that HEAD is always a pointer to the current branch, and the current
  branch always points to its last commit.

  Throw away the last three commits and all current changes (this is a bad
  idea if someone has gotten a copy of these commits from you; this should
  only be done for truly local changes that you no longer want).
      \$ eg reset --working-copy HEAD~3

  Unrecord the last two commits, but keep the changes corresponding to these
  commits in the working copy.  (This can be used to fix a set of \"broken\"
  commits.)
      \$ eg reset HEAD~2

  While working on the \"stable\" branch, you decide that the last 5 commits
  should have been part of a separate branch.  Here's how you retroactively
  make it so:
      <Verify that your working copy is clean>
      \$ eg branch difficult_bugfix
      \$ eg reset --working-copy HEAD~5
      \$ eg switch difficult_bugfix
  The first step creates a new branch that initially could be considered an
  alias for the stable branch, but does not switch to it.  The second step
  moves the stable branch tip back 5 commits and modifies the working copy
  to match.  The last step switches to the difficult_bugfix branch, which
  updates the working copy with the contents of that branch.  Thus, in the
  end, the working copy will have the same contents as before you executed
  these three steps (unless you had local changes when you started, in
  which case those local changes will be gone).

  Stage files (mark changes in them as good and ready for commit but
  without yet committing them), then change your mind and unstage all
  files.
      \$ eg add foo.c bla.h
      \$ eg reset HEAD
  Note that using HEAD as the commit means to forget all commits since HEAD
  (always an empty set) and undo any staged changes since that commit.

Options:
  --working-copy
    Also make the working tree match the version of the repository recorded
    in the specified commit.  If this option is not present, the working
    copy will not be modified.

  --no-unstaging
    Do not modify the staging area; only change the current branch
    pointer to the older commit.

  <commit>
    A reference to a recorded version of the repository, defaulting to HEAD
    (meaning the most recent commit on the current branch).  See 'eg help
    topic commit-ids' for more details.

";
  $self->{'differences'} = '
  The only differences between eg reset and git reset are cosmetic;
  further, eg reset accepts all options and flags that git reset accepts.

  git reset uses option names of --soft, --mixed, and --hard.  While eg
  reset will accept these option names for compatibility, it provides
  alternative names that are more meaningful:
    --working-copy     <=> --hard
    --no-unstaging     <=> --soft
  There is no alternate name for --mixed, since it is the default and thus
  does not need to appear on the command line at all.

  The modified revert command of eg is encouraged for reverting specific
  files, though eg reset has the same file-specific reverting that git
  reset does.
';
  return $self;
}

sub preprocess {
  my $self = shift;
  my $package_name = ref($self);

  #
  # Parse options
  #
  my ($hard, $soft) = (0, 0);
  my $result = main::GetOptions(
    "--help"         => sub { $self->help() },
    "--working-copy" => \$hard,
    "--no-unstaging" => \$soft,
    );
  die "Cannot specify both --working-copy and --no-unstaging!\n"
    if $hard && $soft;
  unshift(@ARGV, "--hard") if $hard;
  unshift(@ARGV, "--soft") if $soft;
}

###########################################################################
# revert                                                                  #
###########################################################################
package revert;
@revert::ISA = qw(subcommand);
INIT {
  $command{revert} = {
    extra => 1,
    section => 'modification',
    about => 'Revert local changes and/or changes in previous commits'
    };
}

sub new {
  my $class = shift;
  my $self = $class->SUPER::new();
  bless($self, $class);
  $self->{'help'} = "
Usage:
  eg revert [--commit | --no-commit] [-m <parent-number>] [--staged]
            [--in | --since] [<commit>] [--] [<path>...]

Description:
  Undoes previous changes, optionally also immediately making a commit once
  the old version of the files are obtained (by default, no commit is
  performed).  This command has many options for exactly what to revert,
  and it may be useful to skip to the examples section below and then come
  back and read the description.

  By default, changes made by this command are only performed in the
  working copy.  As an advanced option, one can instead have the reverting
  be applied to the staging area (the area tracking content explicitly
  marked by you as ready to be committted).

  This command has the ability to either revert changes *since* a given
  commit, or to revert the changes *in* a given commit.  When a commit is
  specified, either the --since or --in flags must also be specified to
  make it clear which behavior is desired.  If no commit is specified and
  neither --since nor --in is provided, then the changes since the last
  commit on the current branch will be reverted (i.e. it behaves like
  \"--since HEAD\" was passed).

  When reverting the changes made *in* a merge commit, the revert command
  needs to know which parent of the merge the revert should be relative to.
  This can be specified using the -m option.

  Finally, revert can operate on a subset of paths if specified.

  To avoid accidental loss of local changes, nothing will be done when no
  arguments are specified.

Examples:
  Undo changes since the last commit on the current branch to bar.h and foo.c.
  This can be done with any of the following three methods (method #3 only
  works if you are in the toplevel directory, though):
      \$ eg revert bar.h foo.c                      # Method #1
      \$ eg revert --since HEAD bar.h foo.c         # Method #2, more explicit
      \$ eg diff bar.h foo.c | patch -p1 -R         # Method #3, using diff

  While on the bling branch, revert the changes in the last 3 commits (as
  well as any local changes).  This can be done with either of (assuming you
  are in the toplevel directory for method #2):
      \$ eg revert --since bling~3                  # Method #1
      \$ eg diff bling~3 | patch -p1 -R             # Method #2, using diff

  While on the stable branch, you determine that the seventh commit prior
  to the most recent was faulty and you simply want to undo it.  This can
  be accomplished by either of (assuming you are in the toplevel directory
  for method #2):
      \$ eg revert --in stable~7                    # Method #1
      \$ eg diff stable~8 stable~7 | patch -p1 -R   # Method #2, using diff

  You decide that all changes to foobar.cpp in your working copy and in the
  last 2 commits are bad and want to revert them.  This is done by either
  of (assuming you are in the toplevel directory for method #2):
      \$ eg revert --since HEAD~2 -- foobar.c       # Method #1
      \$ eg diff HEAD~2 foobar.c | patch -p1 -R     # Method #2, using diff

  You decide that some of the changes in the merge commit HEAD~4 are bad.
  You would like to revert the changes in HEAD~4 relative to its second
  parent.  This can be accomplished as follows (the second method only
  works if you are in the toplevel directory):
      \$ eg revert -m 2 --in HEAD~4                 # Method #1
      \$ eg diff HEAD~4^2 HEAD~4 | patch -p1 -R     # Method #2, using diff
  
  (Advanced) Undo a previous add, marking foo.c as not being ready for
  commit.  The second form could also use eg instead of git, but that usage
  of eg reset is not advertised and exists only for backwards compatibility.
      \$ eg revert --staged foo.c                   # Method #1
      \$ git reset --mixed HEAD foo.c               # Method #2, using git

  (Advanced) You decide that the changes to abracadabra.xml made in commit
  HEAD~8 are bad.  You want to revert those changes in the version of
  abracadabra.xml currently in the staging area.  This is done by:
      \$ eg revert --staged --in HEAD~8 -- abracadabra.xml

Options:
  --commit
    Commit your files immediately after reverting.  There must be no local
    changes prior to running revert if this option is used.  --commit is not
    the default.

  --no-commit
    The opposite of --commit, this flag is the default and exists just for
    completeness.

  -m <parent-number>
    When reverting the changes made in a merge commit, the revert command
    needs to know which parent of the merge the revert should be relative
    to.  Use this flag with the parent number (1, 2, 3...) to specify which
    parent commit to revert relative to.

    Can only be used with the --in option.

  --staged
    Instead of changing files in the working copy, change staged files.

  --in
    Revert the changes made in the specified commit.  This takes the
    difference between the parent of the specified commit and the specified
    commit and reverse applies it.

  --since
    Revert the changes made since the specified commit, including any local
    changes.  This takes the difference between the specified commit and
    the current version of the files and reverses these changes.

  <commit>
    A reference to a recorded version of the repository, defaulting to HEAD
    (meaning the most recent commit on the current branch).  See 'eg help
    topic commit-ids' for more details.

  --
    This option can be used to separate command-line options and commits
    from the list of files, (useful when filenames might be mistaken for
    command-line options or be mistaken as a branch or tag name).

  <path>...
    One or more files or directories.  The changes reverted will be limited
    to the listed files or files below the listed directories.
";
  $self->{'differences'} = '
  git revert is a strict subset of the capabilities of eg revert; eg revert
  also contains part of the abilities of the git checkout and git reset
  commands (namely, the second form of each), as well as a couple new
  things to round it all out.

  Due to these changes, eg revert should be much more welcoming to users of
  svn, hg, bzr, or darcs (all of which assume the --since behavior for
  revert), while also still having the capabilities of git revert (which
  assumes the --in behavior of revert).  This also makes the reset and
  checkout/switch subcommands of eg easier to understand by limiting their
  scope instead of each having two very different capabilities.
  (Technically, eg reset and eg checkout still have those capabilities for
  backwards compatibility, I just omit them in the documentation.)

  The biggest surprises for users of git revert are:
    1) They have to specify the --in flag
    2) No commit is made by default; --commit must be specified to get one
  Neither of these will cause data loss; they will just require a bit more
  work.

  It seems that perhaps eg revert should be extended further, to accept
  things like
      \$ eg revert --in HEAD~8..HEAD~5
  to allow reverting changes made in a range of commits.  The --in could
  even be optional in such a case, since the range makes it clear.
';
  return $self;
}

sub preprocess {
  my $self = shift;
  my $package_name = ref($self);

  if (!@ARGV) {
    die "fatal: You must specify arguments to revert to have local changes\n" .
        "reverted (and lost).  To revert all local changes in the working\n" .
        "copy, use\n" .
        "  eg revert --since HEAD\n"
  }

  my $result = main::GetOptions(
    "--help"         => sub { $self->help() }
    );

  die "Sorry, eg revert has not yet been implemented.\n";
}

###########################################################################
# status                                                                  #
###########################################################################
package status;
@status::ISA = qw(subcommand);
INIT {
  $command{status} = {
    section => 'discovery',
    about => 'Summarize current changes'
    };
}

sub new {
  my $class = shift;
  my $self = $class->SUPER::new();
  bless($self, $class);
  $self->{'help'} = "
Usage:
  eg status

Description:
  Show the current state of the project.  In addition to showing the
  currently active branch, this command will list files with content in any
  of the following states:

     Untracked
       Files that are not explicitly ignored (i.e. do not appear in an
       ignore list such as a .gitignore file) but whose contents are still
       not tracked by git.

       These files can become tracked by running 'eg add <filename>', or
       ignored by having their name added to a .gitignore file.

     Changed but not updated (\"unstaged\")
       Files whose contents have been modified in the working copy.

       (Advanced usage note) If you explicitly mark all the changes in a
       file as ready to be committed, then the file will not appear in this
       list and will instead appear in the \"staged\" list (see below).
       However, a file can appear in both the unstaged and staged lists if
       only part of the changes in the file are marked as ready for commit.

     Changes ready to be committed (\"staged\")
       Files with content changes that have explicitly been marked as ready
       to be committed.  This state only typically appears in advanced
       usage.

       Files enter this state through the use of 'eg add'.  Files can
       return to the unstaged state by running 'eg reset HEAD <file>'.  See
       'eg help topic staging' to learn about the staging area.
";
  $self->{'differences'} = '
  eg status output is essentially just a streamlined and cleaned version of
  git status output.  The streamlining serves to avoid information overload
  to new users (which is only possible with a less error prone "commit"
  command) and the cleaning (removal of leading hash marks) serves to make
  the system more inviting to new users.  There are slight changes to the
  section names to reinforce consistent naming when referring to the same
  concept, but the changes are very slight.
  ';
  return $self;
}

sub postprocess {
  my $self = shift;
  my $output = shift;

  my $branch;
  my %files = ( untracked => undef, unstaged => undef, staged => undef );

  my @lines = split('\n', $output);
  my $cur_state = 0;
  while (@lines) {
    my $line = shift @lines;
    my $section = undef;

    if ($line =~ m/^# On branch (.*)$/) {
      $branch = $1;
    } elsif ($line =~ m/^# Untracked files:$/) {
      $cur_state = 1;
      $section = 'untracked';
      $title = "Untracked files:";
    } elsif ($line =~ m/^# Changes to be committed:$/) {
      $cur_state = 2;
      $section = 'staged';
      $title = 'Changes ready to be committed ("staged"):';
    } elsif ($line =~ m/^# Changed but not updated:$/) {
      $cur_state = 2;
      $section = 'unstaged';
      $title = 'Changed but not updated ("unstaged"):';
    }

    # If we're inside a section type, parse it
    if ($cur_state > 0) {
      my @section_files;
      my $hint = shift @lines;
      shift @lines; # Get rid of blank line

      $line = shift @lines;
      while (defined $line && $line =~ m/^#.+$/) {
        if ($cur_state == 1) {
          if ($line =~ m/^#(\s+)(.*)/) { 
            my $file = $2;
            push @section_files, "$1$file";
          }
        } elsif ($cur_state == 2) {
          if ($line =~ m/^#(\s+.*:\s+)(.*)/) {
            my $file = $2;
            push(@section_files, "$1$file");
          }
        }
        $line = shift @lines;
      }

      if (defined($files{$section})) {
        push(@{$files{$section}{'file_list'}}, @section_files);
      } else {
        $files{$section} = { title     => $title,
                             hint      => $hint,
                             file_list => \@section_files };
      }

      # Record that we finished parsing this section
      $cur_state = 0;
    }
  }

  # Print out the branch we are on
  print "(On branch $branch)\n";

  # Print out all the various changes
  foreach my $section (sort keys %files) {
    if (defined($files{$section})) {
      print "$files{$section}{'title'}\n";
      foreach my $fileline (@{$files{$section}{'file_list'}}) {
        print "$fileline\n";
      }
    }
  }

}

###########################################################################
# switch                                                                  #
###########################################################################
package switch;
@switch::ISA = qw(subcommand);
INIT {
  $command{switch} = {
    section => 'projects',
    about => 'Switch the working copy to another branch'
    };
}

sub new {
  my $class = shift;
  my $self = $class->SUPER::new(git_equivalent => 'checkout');
  bless($self, $class);
  $self->{'help'} = "
Usage:
  eg switch [-b] <branch>

Description:
  Switches to another branch (an operation that can be done locally, without
  any network connectivity).  Creates the branch first if the -b option is
  passed.

Examples:
  Switch to the 4.8 branch
      \$ eg switch 4.8

  Create a new branch called new_whizbang_feature and switch to it.
      \$ eg switch -b new_whizbang_feature

Options:
  -b
    Specifies that the branch should first be created (an error will be shown
    if the specified branch already exists).
";
  $self->{'differences'} = '
  eg switch is a subset of the functionality of git checkout; the abilities
  and flags for creating and switching branches are identical between the
  two, just the name of the function is different.

  The ability of git checkout to get older versions of files is not part of
  eg switch; instead that ability can be found with eg revert.

  (One can also use eg checkout identically to git checkout for backwards
   compatibility; it simply is not an advertised function.)
  ';
  return $self;
}

sub preprocess {
  my $self = shift;

  # Don't let them try to use eg switch to check out older revisions of files;
  # this is just supposed to be a subset of git checkout
  my ($files, $opts, $revs) = Util::git_rev_parse(@ARGV);
  die "Use revert or checkout to obtain older versions of files.\n" if @$files;

  $self->SUPER::preprocess();
}

sub run {
  my $self = shift;
  my $package_name = ref($self);

  return ExecUtil::execute("git checkout @ARGV", ignore_ret => 1);
}

###########################################################################
# version                                                                 #
###########################################################################
package version;
@version::ISA = qw(subcommand);

# Override help because we don't want to both definining $command{help}
sub help {
  my $self = shift;

  $self->{'help'} = "
Usage:
  eg version

Description:
  Show the current version of eg.
";

  open(OUTPUT, "|less");
  print OUTPUT $self->{'help'};
  close(OUTPUT);
  exit 0;
}

sub run {
  my $self = shift;

  print "eg version $version\n";
  $self->SUPER::run();
}



#*************************************************************************#
#*************************************************************************#
#*************************************************************************#
#                             UTILITY CLASSES                             #
#*************************************************************************#
#*************************************************************************#
#*************************************************************************#

###########################################################################
# ExecUtil                                                                #
###########################################################################
package ExecUtil;

# _execute_impl is the guts for execute() and execute_captured()
sub _execute_impl {
  my ($command, @opts) = @_;
  my ($ret, $output);
  my %options = ( ignore_ret => 0, capture_output => 0, @opts );

  if ($verbose) {
    print "eg: running >>$command<<";
    print "\n";
  }

  #
  # Execute the relevant command, in a subdirectory if needed, and capturing
  # stdout and stderr if wanted
  #
  if ($options{capture_output}) {
    $output = `$command 2>&1`;
    $ret = $?;
  } elsif (defined $outfh) {
    open(OUTPUT, "$command 2>&1 |");
    while (<OUTPUT>) {
      print $outfh $_;
    }
    close(OUTPUT);
    $ret = $?;
  } else {
    system($command);
    $ret = $?;
  }

  #
  # Determine retval
  #
  if ($ret != 0) {
    if (($? & 127) == 2) {
      print STDERR "eg: interrupted\n";
    }
    elsif ($? & 127) {
      print STDERR "eg: received signal ".($? & 127)."\n";
    }
    elsif (! $options{ignore_ret}) {
      print STDERR "eg: failed ($ret)\n" if $verbose;
      if ($ret >> 8 != 0) {
        print STDERR "eg: command ($command) failed\n";
      }
      elsif ($ret != 0) {
        print STDERR "eg: command ($command) died (retval=$ret)\n";
      }
    }
  }

  return $options{capture_output} ? ($ret, $output) : $ret;
}

# executes a command, capturing its output (both STDOUT and STDERR)
sub execute_captured {
  my ($command, @options) = @_;
  return _execute_impl($command, capture_output => 1, @options);
}

# executes a command, returning its chomped output
sub output {
  my ($command, @options) = @_;
  my ($ret, $output) = execute_captured($command, @options);
  die "Failed executing '$command'!\n" if $ret != 0;
  chomp($output);
  return $output
}

# executes a command (output not captured)
sub execute {
  my ($command, @options) = @_;
  return _execute_impl($command, @options);
}

###########################################################################
# RepoUtil                                                                #
###########################################################################
package RepoUtil;

# Return whether or not there are uncommitted changes in the repository.
# Only counts staged changes, unless the -a flag is passed as an argument
sub uncommitted_changes {
  my $flags = shift;

  $flags = "" if !defined $flags;

  my $ret = ExecUtil::execute("git status $flags > /dev/null",
                              ignore_ret => 1);
  # $ret == 0 => there are uncommitted changes.  $ret == 1 => opposite
  return !$ret;
}

# current_branch: Get the currently active branch
sub current_branch {
  my ($ret, $output) = ExecUtil::execute_captured("git symbolic-ref HEAD");
  return undef if $ret != 0;
  chomp($output);
  return $output;
}

sub commit_checks {
  my ($commit_type, $check_for) = @_;
  my %status;

  my ($ret, $output) = ExecUtil::execute_captured("eg status");
  $status{has_untracked_files}  = ($output =~ /^Untracked files:$/m);
  $status{has_unstaged_changes} = ($output =~ /^Changed but not updated/m);
  $status{has_staged_changes}   = ($output =~ /^Changes ready to be commit/m);
  $status{has_no_changes}       =
    ($output =~ /^nothing to commit \(working directory clean\)\n\z/m);

  if ($check_for->{no_changes} && $status{has_no_changes}) {
    print STDERR "Aborting: Nothing to commit (run 'eg status' for details).\n";
    exit 1;
  }
  elsif ($check_for->{untracked} && $check_for->{partially_staged} &&
         $status{has_untracked_files} && 
         $status{has_unstaged_changes} && $status{has_staged_changes}) {
    print STDERR <<EOF;
Aborting: It is not clear which changes should be committed; you have
untracked files, staged (explictly marked as ready for commit) changes, and
unstaged changes all present.  Run 'eg help $commit_type' for details.
EOF
    exit 1;
  }
  elsif ($check_for->{untracked} && $status{has_untracked_files}) {
    print STDERR <<EOF;
Aborting: You have untracked files present and it is not clear whether
they should be committed.  Run 'eg help $commit_type' for details.
EOF
    exit 1;
  }
  elsif ($check_for->{partially_staged} &&
         $status{has_unstaged_changes} && $status{has_staged_changes}) {
    print STDERR <<EOF;
Aborting: It is not clear which changes should be committed; you have both
staged (explictly marked as ready for commit) changes and unstaged changes
present.  Run 'eg help $commit_type' for details.
EOF
    exit 1;
  }

  if ($check_for->{has_tabs}) {
    my $diff_flags = "--staged";
    if ($status{has_unstaged_changes} && !$status{has_staged_changes}) {
      $diff_flags = "";
    }

    ($ret, $output) = ExecUtil::execute_captured("eg diff $diff_flags");
    $status{has_tabs_added} = ($output =~ /^\+.*\t/m);

    if ($status{has_tabs_added}) {
      print STDERR
        "Your changes (see output of 'eg diff $diff_flags') include tabs\n" .
        "in the added lines (or new version of the changed lines).  Please\n" .
        "remove them before committing.\n";
      exit 1;
    }
  }

  return \%status;
}


###########################################################################
# Util                                                                    #
###########################################################################
package Util;

# Return items in @$lista but not in @$listb
sub difference {
  my ($lista, $listb) = @_;
  my %count;

  foreach my $item (@$lista) { $count{$item}++ };
  foreach my $item (@$listb) { $count{$item}-- };

  my @ret = grep { $count{$_} == 1 } keys %count;
}

# Have git's rev-parse command parse @args and decide which part is files,
# which is options, and which are revisions.  Further, have git translate
# revisions into full 40-character hexadecimal commit ids.
sub git_rev_parse {
  my @args = @_;

  my ($ret, $output) = 
    ExecUtil::execute_captured("git rev-parse @ARGV", ignore_ret => 1);
  if ($ret != 0) {
    $output =~ /^(fatal:.*)$/m   && print STDERR "$1\n";
    $output =~ /^(Use '--'.*)$/m && print STDERR "$1\n";
    exit 1;
  }
  my @files = split('\n', `git rev-parse --no-revs --no-flags @ARGV`);
  my @opts  = split('\n', `git rev-parse --no-revs --flags    @ARGV`);
  my @revs  = split('\n', `git rev-parse --revs-only          @ARGV`);

  return (\@files, \@opts, \@revs);
}



#*************************************************************************#
#*************************************************************************#
#*************************************************************************#
#                              MAIN PROGRAM                               #
#*************************************************************************#
#*************************************************************************#
#*************************************************************************#

package main;

sub launch {
  my $job=shift;

  my $action;
  $action = $job->new()                      if  $job->can("new");
  $action = subcommand->new(command => $job) if !$job->can("new");
  $action->preprocess() if $action->can("preprocess");

  if (!$action->can("postprocess")) {
    $action->run();
  } else {
    my $output = "";
    open($outfh, '>', \$output) || die "eg $job: cannot open \$outfh: $!";
    $action->run();
    $action->postprocess($output);
  }

  # Do any wrapup required
  $action->wrapup() if $action->can("wrapup");;
}

sub version {
  print "eg version $version\n";
  exit 0;
}

# User gave invalid input; print an error_message, then show command usage
sub help {
  my $error_message = shift;
  my %extra_args;

  # Clear out any arguments so that help object doesn't think we asked for
  # a specific help topic.
  @ARGV = ();

  # Print any error message we were given
  if (defined $error_message) {
    print STDERR "$error_message\n\n";
    $extra_args{exit_status} = 1;
  }

  # Now show help.
  my $help_obj = "help"->new(%extra_args);
  $help_obj->run();
}

sub main {
  #
  # Get any global options 
  #
  Getopt::Long::Configure("no_bundling", "no_permute", "pass_through");
  my $result=GetOptions(
               "--help"    => sub { help() },
               "--verbose" => \$verbose,
               "--version" => sub { version() },
                        );
  help("eg: Error parsing arguments.") if !$result;
  help("eg: No subcommand specified.") if @ARGV < 1;
  help("eg: Invalid argument '$ARGV[0]'.") if ($ARGV[0] !~ m#^[a-z]#);

  #
  # Set up an interrupt signal handler
  #
  $SIG{INT}=sub {
    print STDERR "eg: interrupted\n";
    exit 2;
  };

  #
  # Now execute the action
  #
  my $action = shift @ARGV;
  launch($action);
}

main();
