#!/usr/bin/perl

## Easy GIT (eg), a usable version of git.
## Copyright 2008 by Elijah Newren
## Licensed under GNU GPL, version 2.

package main;

use warnings;
use Getopt::Long;
use List::Util qw(min max);

# configurables
my $verbose=0;

# globals :-(
my $version = "0.5.4.alphabeticalcharactersdontbelonginversionnumbers";
my %command;    # command=>{section, short_description} mapping
my $section = {
  'creation' =>
    { order => 1,
      desc  => 'Creating and updating projects and project containers',
    },
  'discovery' =>
    { order => 2,
      desc  => 'Obtaining information about changes, history, & state',
    },
  'modification' =>
    { order => 3,
      desc  => 'Making, undoing, or recording changes',
    },
  'projects' =>
    { order => 4,
      desc  => 'Managing multiple projects (branches) & collaboration'
    },
  'misc' =>
    { order => 5,
      desc  => 'Miscellaneous'
    },
  };



#*************************************************************************#
#*************************************************************************#
#*************************************************************************#
#                   CLASSES DEFINING ACTIONS TO PERFORM                   #
#*************************************************************************#
#*************************************************************************#
#*************************************************************************#

###########################################################################
# subcommand, a base class for all eg subcommands                         #
###########################################################################
package subcommand;
sub new {
  my $class = shift;
  my $self = {@_};  # Hashref initialized as we're told
  bless($self, $class);
  return $self;
}

sub help {
  my $self = shift;
  my $package_name = ref($self);

  open(OUTPUT, "|less");
  print OUTPUT "$package_name: $command{$package_name}{about}\n";
  print OUTPUT $self->{'help'};
  close(OUTPUT);
  exit 0;
}

sub preprocess {
  my $self = shift;

  my $result=main::GetOptions("--help" => sub { $self->help() });
}

sub run {
  my $self = shift;
  my $package_name = ref($self);

  ExecUtil::execute("git $package_name @ARGV", ignore_ret => 1);
}

###########################################################################
# branch                                                                  #
###########################################################################
package branch;
@branch::ISA = qw(subcommand);
INIT {
  $command{branch} = {
    section => 'projects',
    about => 'List existing projects (branches)'
    };
}

sub new {
  my $class = shift;
  my $self = $class->SUPER::new();
  bless($self, $class);
  $self->{'help'} = "
Usage:
  eg branch

Description:
  List the existing branches that you can switch to, with the
  currently active branch marked with an asterisk.
";
  return $self;
}

# Parent class preprocess, help, and run methods work for us

###########################################################################
# help                                                                    #
###########################################################################
package help;
@help::ISA = qw(subcommand);
INIT {
  $command{help} = {
    section => 'misc',
    about => 'Get command syntax and examples'
    };
}

sub new {
  my $class = shift;
  my $self = $class->SUPER::new(exit_status => 0, @_);
  bless($self, $class);
  $self->{'help'} = "
Usage:
  eg help [<subtopic>]

Description:
  Shows general help for eg, for one of its subcommands, or for a
  specialized topic.

Examples:
  Show help for eg
      \$ eg help

  Show help for the switch command of eg
      \$ eg help switch

  Show which topics have available help
      \$ eg help topic

  Show the help for the index (staging area) topic
      \$ eg help topic index
";
  return $self;
}

sub preprocess {
  my $self = shift;
  my $package_name = ref($self);

  my $result=main::GetOptions("--help" => sub { $self->help() });

  # Check if we were asked to get help on a subtopic rather than toplevel help
  if (@ARGV == 1) {
    die "Oops, there's a bug.\n" if $self->{exit_status} != 0;
    my $subcommand = shift @ARGV;
    my $subcommand_obj = $subcommand->new();
    $subcommand_obj->help();
  } elsif (@ARGV > 1) {
    @$self{'exit_status', 'be_a_jerk'} = (1, 0);
    print STDERR "Too many arguments to help.\n";
  }

  # Print valid subcommands sorted by section
  foreach my $name (sort
                    {$section->{$a}{'order'} <=> $section->{$b}{'order'}}
                    keys %$section) {
    print "$section->{$name}{desc}\n";
    foreach my $c (keys %command) {
      next if $command{$c}{section} ne $name;
      printf "  eg %-15s %s\n", $c, $command{$c}{about};
    }
    print "\n";
  }

  # Check to see if someone added a command with an invalid section
  my $broken_commands = "";
  foreach my $c (keys %command) {
    next if defined $section->{$command{$c}{section}};
    printf "    -%15s %s\n", $c, $command{$c}{about};
  }
  if ($broken_commands) {
    print "Broken (typo in classification?) commands:\n$broken_commands";
  }

  # And let them know how to get more detailed help...
  print "Type 'eg help <command>' to get more help on <command>.\n";
  
  exit $self->{exit_status};
}

###########################################################################
# status                                                                  #
###########################################################################
package status;
@status::ISA = qw(subcommand);
INIT {
  $command{status} = {
    section => 'discovery',
    about => 'Summarize current changes'
    };
}

sub new {
  my $class = shift;
  my $self = $class->SUPER::new();
  bless($self, $class);
  $self->{'help'} = "
Usage:
  eg status

Description:
  Show the current state of the project.  In addition to showing the
  currently active branch, this command will list files with content in any
  of the following states:

     Untracked
       Files that are not explicitly ignored (i.e. do not appear in an
       ignore list such as a .gitignore file) but whose contents are still
       not tracked by git.  These files can become tracked by running
       'eg add <filename>'.

     Changed but not updated
       Files whose contents have been modified in the working copy.  If you
       have explicitly staged changes (i.e. marked them as ready to be
       committed by running eg add), then those changes will not cause the
       filename to appear in this list.

     Changes to be committed
       Files with contents that have been marked as ready to be committed
       (also known as 'staged').  Files enter this state through the use of
       'eg add'. See 'eg help topic index' to learn about the staging area.
";
  return $self;
}

# Parent class preprocess, help, and run methods work for us



#*************************************************************************#
#*************************************************************************#
#*************************************************************************#
#                             UTILITY CLASSES                             #
#*************************************************************************#
#*************************************************************************#
#*************************************************************************#

###########################################################################
# ExecUtil                                                                #
###########################################################################
package ExecUtil;

# _execute_impl is the guts for execute() and execute_captured()
sub _execute_impl {
  my ($command, @opts) = @_;
  my ($ret, $output);
  my %options = ( ignore_ret => 0, capture_output => 0, @opts );

  if ($verbose) {
    print "eg: running >>$command<<";
    print "\n";
  }

  #
  # Execute the relevant command, in a subdirectory if needed, and capturing
  # stdout and stderr if wanted
  #
  if ($options{capture_output}) {
    $output = `$command 2>&1`;
    $ret = $?;
  } else {
    $ret=system($command);
  }

  #
  # Determine retval
  #
  if ($ret != 0) {
    if (($? & 127) == 2) {
      print STDERR "eg: interrupted\n";
    }
    elsif ($? & 127) {
      print STDERR "eg: received signal ".($? & 127)."\n";
    }
    elsif (! $options{ignore_ret}) {
      print STDERR "eg: failed ($ret)\n" if $verbose;
      if ($ret >> 8 != 0) {
        print STDERR "eg: command ($command) failed\n";
      }
      elsif ($ret != 0) {
        print STDERR "eg: command ($command) died (retval=$ret)\n";
      }
    }
  }

  # Return OK/ABORT/FAILED and optionally the command output
  return $options{capture_output} ? $output : undef;
}

# executes a command, capturing its output (both STDOUT and STDERR)
sub execute_captured {
  my ($command, @options) = @_;

  my $output = _execute_impl($command, capture_output => 1, @options);
  return $output;
}

# executes a command (output not captured)
sub execute {
  my ($command, @options) = @_;

  _execute_impl($command, @options);  
}

###########################################################################
# RepoUtil                                                                #
###########################################################################
package RepoUtil;

# Return whether or not there are uncommitted changes in the repository.
# Only counts indexed changes, unless the -a flag is passed as an argument
sub uncommitted_changes {
  my $flags = shift;

  $flags = "" if !defined $flags;

  my $ret = ExecUtil::execute("git status $flags > /dev/null",
                              undef, "ignore retval");
  # $ret == 0 => there are uncommitted changes.  $ret == 1 => opposite
  return !$ret;
}

sub commit_checks {
  my ($commit_type, $check_for) = @_;
  my %status;

  my ($ret, $output) = ExecUtil::execute_captured("eg status");
  $status{has_untracked_files}  = ($output =~ /^# Untracked files:$/m);
  $status{has_unstaged_changes} = ($output =~ /^# Changed but not updated:$/m);
  $status{has_staged_changes}   = ($output =~ /^# Changes to be committed:$/m);
  $status{has_no_changes}       =
    ($output =~ /^nothing to commit \(working directory clean\)\n\z/m);

  if ($check_for->{no_changes} && $status{has_no_changes}) {
    print STDERR "Aborting: Nothing to commit (run 'eg status' for details).\n";
    exit 1;
  }
  elsif ($check_for->{untracked} && $check_for->{partially_staged} &&
         $status{has_untracked_files} && 
         $status{has_unstaged_changes} && $status{has_staged_changes}) {
    print STDERR <<EOF;
Aborting: It is not clear which changes should be committed; you have
untracked files, staged (explictly marked as ready for commit) changes, and
unstaged changes all present.  Run 'eg help $commit_type' for details.
EOF
    exit 1;
  }
  elsif ($check_for->{untracked} && $status{has_untracked_files}) {
    print STDERR <<EOF;
Aborting: You have untracked files present and it is not clear whether
they should be committed.  Run 'eg help $commit_type' for details.
EOF
    exit 1;
  }
  elsif ($check_for->{partially_staged} &&
         $status{has_unstaged_changes} && $status{has_staged_changes}) {
    print STDERR <<EOF;
Aborting: It is not clear which changes should be committed; you have both
staged (explictly marked as ready for commit) changes and unstaged changes
present.  Run 'eg help $commit_type' for details.
EOF
    exit 1;
  }

  if ($check_for->{has_tabs}) {
    my $diff_flags = "--staged";
    if ($status{has_unstaged_changes} && !$status{has_staged_changes}) {
      $diff_flags = "";
    }

    ($ret, $output) = ExecUtil::execute_captured("eg diff $diff_flags");
    $status{has_tabs_added} = ($output =~ /^\+.*\t/m);

    if ($status{has_tabs_added}) {
      print STDERR
        "Your changes (see output of 'eg diff $diff_flags') include tabs\n" .
        "in the added lines (or new version of the changed lines).  Please\n" .
        "remove them before committing.\n";
      exit 1;
    }
  }

  return \%status;
}


###########################################################################
# Util                                                                    #
###########################################################################
package Util;

# Return items in @$lista but not in @$listb
sub difference {
  my ($lista, $listb) = @_;
  my %count;

  foreach my $item (@$lista) { $count{$item}++ };
  foreach my $item (@$listb) { $count{$item}-- };

  my @ret = grep { $count{$_} == 1 } keys %count;
}

# Have git's rev-parse command parse @args and decide which part is files,
# which is options, and which are revisions.  Further, have git translate
# revisions into full 40-character hexadecimal commit ids.
sub git_rev_parse {
  my @args = @_;

  my ($ret, $output) = 
    ExecUtil::execute_captured("git rev-parse @ARGV", undef, "ignore-ret");
  if ($ret != 0) {
    $output =~ /^(fatal:.*)$/m   && print STDERR "$1\n";
    $output =~ /^(Use '--'.*)$/m && print STDERR "$1\n";
    exit 1;
  }
  my @files = split('\n', `git rev-parse --no-revs --no-flags @ARGV`);
  my @opts  = split('\n', `git rev-parse --no-revs --flags    @ARGV`);
  my @revs  = split('\n', `git rev-parse --revs-only          @ARGV`);

  return (\@files, \@opts, \@revs);
}



#*************************************************************************#
#*************************************************************************#
#*************************************************************************#
#                              MAIN PROGRAM                               #
#*************************************************************************#
#*************************************************************************#
#*************************************************************************#

package main;

sub launch {
  my $job=shift;

  my $action=$job->new();
  $action->preprocess() if $action->can("preprocess");

  if (!$action->can("postprocess")) {
    $action->run();
  } else {
    # Redirect stdout and stderr
    pipe(my $outfh, OUTPUT);
    open(STDOUT, ">&OUTPUT") || die "eg $job cannot reopen stdout: $!";
    open(STDERR, ">&OUTPUT") || die "eg $job cannot reopen stderr: $!";
    close OUTPUT;

    # Run the action
    $action->run();

    # Get the output
    my @all_output = <$outfh>;
    my $output = join('\n', @all_output);
    #read($outfh, $output) || die "Couldn't read all output: $!";
    close $outfh;

    # Run the postprocess command
    $action->postprocess($output);
  }

  # Do any wrapup required
  $action->wrapup() if $action->can("wrapup");;
}

sub version {
  print "eg version $version\n";
  exit 0;
}

# User gave invalid input; print an error_message, then show command usage
sub help {
  my $error_message = shift;
  my %extra_args;

  # Clear out any arguments so that help object doesn't think we asked for
  # a specific help topic.
  @ARGV = ();

  # Print any error message we were given
  if (defined $error_message) {
    print STDERR "$error_message\n\n";
    $extra_args{exit_status} = 1;
  }

  # Now show help.
  my $help_obj = "help"->new(%extra_args);
  $help_obj->run();
}

sub main {
  #
  # Get any global options 
  #
  Getopt::Long::Configure("no_bundling", "no_permute", "pass_through");
  my $result=GetOptions(
               "--help"    => sub { help() },
               "--verbose" => \$verbose,
               "--version" => sub { version() },
                        );
  help("eg: Error parsing arguments.") if !$result;
  help("eg: No subcommand specified.") if @ARGV < 1;

  #
  # Set up an interrupt signal handler
  #
  $SIG{INT}=sub {
    print STDERR "eg: interrupted\n";
    exit 2;
  };

  #
  # Now execute the action
  #
  my $action = shift @ARGV;
  launch($action);
}

main();
